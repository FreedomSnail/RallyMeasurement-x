; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_i2c_gpio.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_i2c_gpio.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F405xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\bsp_i2c_gpio.crf ..\..\User\bsp_stm32f4xx\src\bsp_i2c_gpio.c]
                          THUMB

                          AREA ||i.SDA_IN||, CODE, READONLY, ALIGN=2

                  SDA_IN PROC
;;;69       */  
;;;70     void SDA_IN(void)    
000000  b51c              PUSH     {r2-r4,lr}
;;;71     {    
;;;72     	GPIO_InitTypeDef GPIO_InitStructure;
;;;73       	GPIO_StructInit(&GPIO_InitStructure);    
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       GPIO_StructInit
;;;74       	GPIO_InitStructure.GPIO_Pin   = I2C_SDA_PIN;    
000008  2080              MOVS     r0,#0x80
00000a  9000              STR      r0,[sp,#0]
;;;75       	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;  
00000c  2000              MOVS     r0,#0
00000e  f88d0004          STRB     r0,[sp,#4]
;;;76       	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000012  f88d0007          STRB     r0,[sp,#7]
;;;77       	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;     
000016  2003              MOVS     r0,#3
000018  f88d0005          STRB     r0,[sp,#5]
;;;78       	GPIO_Init(GPIO_PORT_I2C, &GPIO_InitStructure);    
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L1.40|
000020  f7fffffe          BL       GPIO_Init
;;;79     }   
000024  bd1c              POP      {r2-r4,pc}
;;;80     
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x40020400

                          AREA ||i.SDA_OUT||, CODE, READONLY, ALIGN=2

                  SDA_OUT PROC
;;;55       */  
;;;56     void SDA_OUT(void)    
000000  b51c              PUSH     {r2-r4,lr}
;;;57     {    
;;;58     	GPIO_InitTypeDef GPIO_InitStructure;
;;;59       	GPIO_StructInit(&GPIO_InitStructure);    
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       GPIO_StructInit
;;;60       	GPIO_InitStructure.GPIO_Pin   = I2C_SDA_PIN;    
000008  2080              MOVS     r0,#0x80
00000a  9000              STR      r0,[sp,#0]
;;;61       	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    
00000c  2001              MOVS     r0,#1
00000e  f88d0004          STRB     r0,[sp,#4]
;;;62       	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;    
000012  2000              MOVS     r0,#0
000014  f88d0006          STRB     r0,[sp,#6]
;;;63       	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;     
000018  2003              MOVS     r0,#3
00001a  f88d0005          STRB     r0,[sp,#5]
;;;64       	GPIO_Init(GPIO_PORT_I2C, &GPIO_InitStructure);    
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L2.40|
000022  f7fffffe          BL       GPIO_Init
;;;65     }    
000026  bd1c              POP      {r2-r4,pc}
;;;66     /** 
                          ENDP

                  |L2.40|
                          DCD      0x40020400

                          AREA ||i.bsp_InitI2C||, CODE, READONLY, ALIGN=2

                  bsp_InitI2C PROC
;;;34     */
;;;35     void bsp_InitI2C(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;36     {
;;;37     	GPIO_InitTypeDef GPIO_InitStructure;
;;;38     
;;;39     	RCC_AHB1PeriphClockCmd(RCC_I2C_PORT, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;40     
;;;41     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;42     	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		/* 设为开漏模式 */
000010  f88d0006          STRB     r0,[sp,#6]
;;;43     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000014  2000              MOVS     r0,#0
000016  f88d0007          STRB     r0,[sp,#7]
;;;44     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00001a  2003              MOVS     r0,#3
00001c  f88d0005          STRB     r0,[sp,#5]
;;;45     
;;;46     	GPIO_InitStructure.GPIO_Pin = I2C_SCL_PIN | I2C_SDA_PIN;
000020  20c0              MOVS     r0,#0xc0
000022  9000              STR      r0,[sp,#0]
;;;47     	GPIO_Init(GPIO_PORT_I2C, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  4803              LDR      r0,|L3.52|
000028  f7fffffe          BL       GPIO_Init
;;;48     
;;;49     	/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */
;;;50     	i2c_Stop();
00002c  f7fffffe          BL       i2c_Stop
;;;51     }
000030  bd1c              POP      {r2-r4,pc}
;;;52     /** 
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      0x40020400

                          AREA ||i.i2c_Ack||, CODE, READONLY, ALIGN=2

                  i2c_Ack PROC
;;;199    */
;;;200    void i2c_Ack(void)
000000  b510              PUSH     {r4,lr}
;;;201    {
;;;202    	I2C_SCL_0();
000002  2040              MOVS     r0,#0x40
000004  490a              LDR      r1,|L4.48|
000006  8008              STRH     r0,[r1,#0]
;;;203    	SDA_OUT();
000008  f7fffffe          BL       SDA_OUT
;;;204    	
;;;205    	I2C_SDA_0();	/* CPU驱动SDA = 0 */
00000c  2080              MOVS     r0,#0x80
00000e  4908              LDR      r1,|L4.48|
000010  8008              STRH     r0,[r1,#0]
;;;206    	i2c_Delay();
000012  f7fffffe          BL       i2c_Delay
;;;207    	I2C_SCL_1();	/* CPU产生1个时钟 */
000016  2040              MOVS     r0,#0x40
000018  4905              LDR      r1,|L4.48|
00001a  1e89              SUBS     r1,r1,#2
00001c  8008              STRH     r0,[r1,#0]
;;;208    	i2c_Delay();
00001e  f7fffffe          BL       i2c_Delay
;;;209    	I2C_SCL_0();
000022  2040              MOVS     r0,#0x40
000024  4902              LDR      r1,|L4.48|
000026  8008              STRH     r0,[r1,#0]
;;;210    	i2c_Delay();
000028  f7fffffe          BL       i2c_Delay
;;;211    	//I2C_SDA_1();	/* CPU释放SDA总线 */
;;;212    }
00002c  bd10              POP      {r4,pc}
;;;213    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      0x4002041a

                          AREA ||i.i2c_Delay||, CODE, READONLY, ALIGN=1

                  i2c_Delay PROC
;;;89     */
;;;90     static void i2c_Delay(void)
000000  2000              MOVS     r0,#0
;;;91     {
;;;92     	uint8_t i;
;;;93     
;;;94     	/*　
;;;95     		CPU主频168MHz时，在内部Flash运行, MDK工程不优化。用台式示波器观测波形。
;;;96     		循环次数为5时，SCL频率 = 1.78MHz (读耗时: 92ms, 读写正常，但是用示波器探头碰上就读写失败。时序接近临界)
;;;97     		循环次数为10时，SCL频率 = 1.1MHz (读耗时: 138ms, 读速度: 118724B/s)
;;;98     		循环次数为30时，SCL频率 = 440KHz， SCL高电平时间1.0us，SCL低电平时间1.2us
;;;99     
;;;100    		上拉电阻选择2.2K欧时，SCL上升沿时间约0.5us，如果选4.7K欧，则上升沿约1us
;;;101    
;;;102    		实际应用选择400KHz左右的速率即可
;;;103    	*/
;;;104    	for (i = 0; i < 100; i++);
000002  e001              B        |L5.8|
                  |L5.4|
000004  1c41              ADDS     r1,r0,#1
000006  b2c8              UXTB     r0,r1
                  |L5.8|
000008  2864              CMP      r0,#0x64
00000a  dbfb              BLT      |L5.4|
;;;105    }
00000c  4770              BX       lr
;;;106    void i2c_Delay_Test(void)
                          ENDP


                          AREA ||i.i2c_Delay_Test||, CODE, READONLY, ALIGN=2

                  i2c_Delay_Test PROC
;;;105    }
;;;106    void i2c_Delay_Test(void)
000000  b510              PUSH     {r4,lr}
;;;107    {
;;;108    	u8 i;
;;;109    	SDA_OUT();               //sda线输出
000002  f7fffffe          BL       SDA_OUT
;;;110    	for(i=0;i<10;i++) {
000006  2400              MOVS     r4,#0
000008  e00c              B        |L6.36|
                  |L6.10|
;;;111    		//I2C_SDA_0();
;;;112    		I2C_SCL_1();
00000a  2040              MOVS     r0,#0x40
00000c  4907              LDR      r1,|L6.44|
00000e  8008              STRH     r0,[r1,#0]
;;;113    		i2c_Delay();
000010  f7fffffe          BL       i2c_Delay
;;;114    		//I2C_SDA_1();
;;;115    		I2C_SCL_0();
000014  2040              MOVS     r0,#0x40
000016  4905              LDR      r1,|L6.44|
000018  1c89              ADDS     r1,r1,#2
00001a  8008              STRH     r0,[r1,#0]
;;;116    		i2c_Delay();
00001c  f7fffffe          BL       i2c_Delay
000020  1c60              ADDS     r0,r4,#1              ;110
000022  b2c4              UXTB     r4,r0                 ;110
                  |L6.36|
000024  2c0a              CMP      r4,#0xa               ;110
000026  dbf0              BLT      |L6.10|
;;;117    	}
;;;118    }
000028  bd10              POP      {r4,pc}
;;;119    /*
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x40020418

                          AREA ||i.i2c_NAck||, CODE, READONLY, ALIGN=2

                  i2c_NAck PROC
;;;221    */
;;;222    void i2c_NAck(void)
000000  b510              PUSH     {r4,lr}
;;;223    {
;;;224    	I2C_SCL_0();
000002  2040              MOVS     r0,#0x40
000004  490a              LDR      r1,|L7.48|
000006  8008              STRH     r0,[r1,#0]
;;;225    	SDA_OUT();
000008  f7fffffe          BL       SDA_OUT
;;;226    	
;;;227    	I2C_SDA_1();	/* CPU驱动SDA = 1 */
00000c  2080              MOVS     r0,#0x80
00000e  4908              LDR      r1,|L7.48|
000010  1e89              SUBS     r1,r1,#2
000012  8008              STRH     r0,[r1,#0]
;;;228    	i2c_Delay();
000014  f7fffffe          BL       i2c_Delay
;;;229    	I2C_SCL_1();	/* CPU产生1个时钟 */
000018  2040              MOVS     r0,#0x40
00001a  4905              LDR      r1,|L7.48|
00001c  1e89              SUBS     r1,r1,#2
00001e  8008              STRH     r0,[r1,#0]
;;;230    	i2c_Delay();
000020  f7fffffe          BL       i2c_Delay
;;;231    	I2C_SCL_0();
000024  2040              MOVS     r0,#0x40
000026  4902              LDR      r1,|L7.48|
000028  8008              STRH     r0,[r1,#0]
;;;232    	i2c_Delay();
00002a  f7fffffe          BL       i2c_Delay
;;;233    }
00002e  bd10              POP      {r4,pc}
;;;234    /*
                          ENDP

                  |L7.48|
                          DCD      0x4002041a

                          AREA ||i.i2c_ReadByte||, CODE, READONLY, ALIGN=2

                  i2c_ReadByte PROC
;;;271    */
;;;272    uint8_t i2c_ReadByte(uint8_t ack)
000000  b570              PUSH     {r4-r6,lr}
;;;273    {
000002  4605              MOV      r5,r0
;;;274    	uint8_t i;
;;;275    	uint8_t receive=0;
000004  2400              MOVS     r4,#0
;;;276    	SDA_IN();
000006  f7fffffe          BL       SDA_IN
;;;277    	
;;;278    	for (i = 0; i < 8; i++) {
00000a  2600              MOVS     r6,#0
00000c  e016              B        |L8.60|
                  |L8.14|
;;;279    		I2C_SCL_0();
00000e  2040              MOVS     r0,#0x40
000010  490f              LDR      r1,|L8.80|
000012  8008              STRH     r0,[r1,#0]
;;;280    		i2c_Delay();
000014  f7fffffe          BL       i2c_Delay
;;;281    		I2C_SCL_1();
000018  2040              MOVS     r0,#0x40
00001a  490d              LDR      r1,|L8.80|
00001c  1e89              SUBS     r1,r1,#2
00001e  8008              STRH     r0,[r1,#0]
;;;282    		receive <<= 1;
000020  0660              LSLS     r0,r4,#25
000022  0e04              LSRS     r4,r0,#24
;;;283    		if (I2C_SDA_READ()){
000024  480a              LDR      r0,|L8.80|
000026  380a              SUBS     r0,r0,#0xa
000028  6800              LDR      r0,[r0,#0]
00002a  f0000080          AND      r0,r0,#0x80
00002e  b108              CBZ      r0,|L8.52|
;;;284    			receive++;
000030  1c60              ADDS     r0,r4,#1
000032  b2c4              UXTB     r4,r0
                  |L8.52|
;;;285    		}
;;;286    		i2c_Delay();
000034  f7fffffe          BL       i2c_Delay
000038  1c70              ADDS     r0,r6,#1              ;278
00003a  b2c6              UXTB     r6,r0                 ;278
                  |L8.60|
00003c  2e08              CMP      r6,#8                 ;278
00003e  dbe6              BLT      |L8.14|
;;;287    	}
;;;288    	if(ack) {
000040  b115              CBZ      r5,|L8.72|
;;;289    		i2c_Ack();
000042  f7fffffe          BL       i2c_Ack
000046  e001              B        |L8.76|
                  |L8.72|
;;;290    	} else {
;;;291    		i2c_NAck();
000048  f7fffffe          BL       i2c_NAck
                  |L8.76|
;;;292    	}
;;;293    	return receive;
00004c  4620              MOV      r0,r4
;;;294    }
00004e  bd70              POP      {r4-r6,pc}
;;;295    
                          ENDP

                  |L8.80|
                          DCD      0x4002041a

                          AREA ||i.i2c_SendByte||, CODE, READONLY, ALIGN=2

                  i2c_SendByte PROC
;;;241    */
;;;242    void i2c_SendByte(uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;243    {
000002  4604              MOV      r4,r0
;;;244    	uint8_t i;
;;;245    	
;;;246    	SDA_OUT();
000004  f7fffffe          BL       SDA_OUT
;;;247    	I2C_SCL_0();
000008  2040              MOVS     r0,#0x40
00000a  4911              LDR      r1,|L9.80|
00000c  8008              STRH     r0,[r1,#0]
;;;248    	/* 先发送字节的高位bit7 */
;;;249    	for (i = 0; i < 8; i++) {
00000e  2500              MOVS     r5,#0
000010  e01b              B        |L9.74|
                  |L9.18|
;;;250    		if (_ucByte & 0x80){
000012  f0040080          AND      r0,r4,#0x80
000016  b120              CBZ      r0,|L9.34|
;;;251    			I2C_SDA_1();
000018  2080              MOVS     r0,#0x80
00001a  490d              LDR      r1,|L9.80|
00001c  1e89              SUBS     r1,r1,#2
00001e  8008              STRH     r0,[r1,#0]
000020  e002              B        |L9.40|
                  |L9.34|
;;;252    		} else {
;;;253    			I2C_SDA_0();
000022  2080              MOVS     r0,#0x80
000024  490a              LDR      r1,|L9.80|
000026  8008              STRH     r0,[r1,#0]
                  |L9.40|
;;;254    		}
;;;255    		_ucByte <<= 1;	/* 左移一个bit */
000028  0660              LSLS     r0,r4,#25
00002a  0e04              LSRS     r4,r0,#24
;;;256    		i2c_Delay();
00002c  f7fffffe          BL       i2c_Delay
;;;257    		I2C_SCL_1();
000030  2040              MOVS     r0,#0x40
000032  4907              LDR      r1,|L9.80|
000034  1e89              SUBS     r1,r1,#2
000036  8008              STRH     r0,[r1,#0]
;;;258    		i2c_Delay();
000038  f7fffffe          BL       i2c_Delay
;;;259    		I2C_SCL_0();
00003c  2040              MOVS     r0,#0x40
00003e  4904              LDR      r1,|L9.80|
000040  8008              STRH     r0,[r1,#0]
;;;260    		i2c_Delay();
000042  f7fffffe          BL       i2c_Delay
000046  1c68              ADDS     r0,r5,#1              ;249
000048  b2c5              UXTB     r5,r0                 ;249
                  |L9.74|
00004a  2d08              CMP      r5,#8                 ;249
00004c  dbe1              BLT      |L9.18|
;;;261    	}
;;;262    }
00004e  bd70              POP      {r4-r6,pc}
;;;263    
                          ENDP

                  |L9.80|
                          DCD      0x4002041a

                          AREA ||i.i2c_Start||, CODE, READONLY, ALIGN=2

                  i2c_Start PROC
;;;126    */
;;;127    void i2c_Start(void)
000000  b510              PUSH     {r4,lr}
;;;128    {
;;;129    	SDA_OUT();               //sda线输出
000002  f7fffffe          BL       SDA_OUT
;;;130    	/* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */
;;;131    	I2C_SDA_1();
000006  2080              MOVS     r0,#0x80
000008  4909              LDR      r1,|L10.48|
00000a  8008              STRH     r0,[r1,#0]
;;;132    	I2C_SCL_1();
00000c  2040              MOVS     r0,#0x40
00000e  8008              STRH     r0,[r1,#0]
;;;133    	i2c_Delay();
000010  f7fffffe          BL       i2c_Delay
;;;134    	I2C_SDA_0();
000014  2080              MOVS     r0,#0x80
000016  4906              LDR      r1,|L10.48|
000018  1c89              ADDS     r1,r1,#2
00001a  8008              STRH     r0,[r1,#0]
;;;135    	i2c_Delay();
00001c  f7fffffe          BL       i2c_Delay
;;;136    	I2C_SCL_0();
000020  2040              MOVS     r0,#0x40
000022  4903              LDR      r1,|L10.48|
000024  1c89              ADDS     r1,r1,#2
000026  8008              STRH     r0,[r1,#0]
;;;137    	i2c_Delay();
000028  f7fffffe          BL       i2c_Delay
;;;138    }
00002c  bd10              POP      {r4,pc}
;;;139    
                          ENDP

00002e  0000              DCW      0x0000
                  |L10.48|
                          DCD      0x40020418

                          AREA ||i.i2c_Stop||, CODE, READONLY, ALIGN=2

                  i2c_Stop PROC
;;;147    */
;;;148    void i2c_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;149    {
;;;150    	SDA_OUT();               //sda线输出
000002  f7fffffe          BL       SDA_OUT
;;;151    	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
;;;152    	I2C_SCL_0();
000006  2040              MOVS     r0,#0x40
000008  4907              LDR      r1,|L11.40|
00000a  8008              STRH     r0,[r1,#0]
;;;153    	I2C_SDA_0();
00000c  2080              MOVS     r0,#0x80
00000e  8008              STRH     r0,[r1,#0]
;;;154    	i2c_Delay();
000010  f7fffffe          BL       i2c_Delay
;;;155    	I2C_SCL_1();
000014  2040              MOVS     r0,#0x40
000016  4904              LDR      r1,|L11.40|
000018  1e89              SUBS     r1,r1,#2
00001a  8008              STRH     r0,[r1,#0]
;;;156    	I2C_SDA_1();
00001c  2080              MOVS     r0,#0x80
00001e  8008              STRH     r0,[r1,#0]
;;;157    	i2c_Delay();
000020  f7fffffe          BL       i2c_Delay
;;;158    }
000024  bd10              POP      {r4,pc}
;;;159    
                          ENDP

000026  0000              DCW      0x0000
                  |L11.40|
                          DCD      0x4002041a

                          AREA ||i.i2c_WaitAck||, CODE, READONLY, ALIGN=2

                  i2c_WaitAck PROC
;;;167    */
;;;168    uint8_t i2c_WaitAck(void)
000000  b510              PUSH     {r4,lr}
;;;169    {
;;;170    	uint8_t ucErrTime=0;
000002  2400              MOVS     r4,#0
;;;171    	
;;;172    	SDA_IN();      //SDA设置为输入
000004  f7fffffe          BL       SDA_IN
;;;173    
;;;174    	I2C_SDA_1();	/* CPU释放SDA总线 */
000008  2080              MOVS     r0,#0x80
00000a  4910              LDR      r1,|L12.76|
00000c  8008              STRH     r0,[r1,#0]
;;;175    	
;;;176    	i2c_Delay();
00000e  f7fffffe          BL       i2c_Delay
;;;177    	I2C_SCL_1();	/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
000012  2040              MOVS     r0,#0x40
000014  490d              LDR      r1,|L12.76|
000016  8008              STRH     r0,[r1,#0]
;;;178    	i2c_Delay();
000018  f7fffffe          BL       i2c_Delay
;;;179    	while (I2C_SDA_READ())	/* CPU读取SDA口线状态 */
00001c  e007              B        |L12.46|
                  |L12.30|
;;;180    	//while (SDA_READ())
;;;181    	{
;;;182    		ucErrTime++;
00001e  1c60              ADDS     r0,r4,#1
000020  b2c4              UXTB     r4,r0
;;;183    		if(ucErrTime>250) {
000022  2cfa              CMP      r4,#0xfa
000024  dd03              BLE      |L12.46|
;;;184    			i2c_Stop();
000026  f7fffffe          BL       i2c_Stop
;;;185    			return 1;
00002a  2001              MOVS     r0,#1
                  |L12.44|
;;;186    		}
;;;187    	}
;;;188    	I2C_SCL_0();
;;;189    	i2c_Delay();
;;;190    	return 0;
;;;191    }
00002c  bd10              POP      {r4,pc}
                  |L12.46|
00002e  4807              LDR      r0,|L12.76|
000030  3808              SUBS     r0,r0,#8              ;179
000032  6800              LDR      r0,[r0,#0]            ;179
000034  f0000080          AND      r0,r0,#0x80           ;179
000038  2800              CMP      r0,#0                 ;179
00003a  d1f0              BNE      |L12.30|
00003c  2040              MOVS     r0,#0x40              ;188
00003e  4903              LDR      r1,|L12.76|
000040  1c89              ADDS     r1,r1,#2              ;188
000042  8008              STRH     r0,[r1,#0]            ;188
000044  f7fffffe          BL       i2c_Delay
000048  2000              MOVS     r0,#0                 ;190
00004a  e7ef              B        |L12.44|
;;;192    /*
                          ENDP

                  |L12.76|
                          DCD      0x40020418

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_i2c_gpio.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_i2c_gpio_c_ec180c52____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_bsp_i2c_gpio_c_ec180c52____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_i2c_gpio_c_ec180c52____REVSH|
#line 128
|__asm___14_bsp_i2c_gpio_c_ec180c52____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
