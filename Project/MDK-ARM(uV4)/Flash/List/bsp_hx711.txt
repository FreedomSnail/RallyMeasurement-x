; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_hx711.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_hx711.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F405xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\bsp_hx711.crf ..\..\User\bsp_stm32f4xx\src\bsp_hx711.c]
                          THUMB

                          AREA ||i.Delay_Hx711_Us||, CODE, READONLY, ALIGN=1

                  Delay_Hx711_Us PROC
;;;69     ************************************************************************************************/
;;;70     void Delay_Hx711_Us(void)
000000  2000              MOVS     r0,#0
;;;71     {
;;;72     	u16 i;
;;;73     	for(i=0;i<180;i++) {
000002  e001              B        |L1.8|
                  |L1.4|
000004  1c41              ADDS     r1,r0,#1
000006  b288              UXTH     r0,r1
                  |L1.8|
000008  28b4              CMP      r0,#0xb4
00000a  dbfb              BLT      |L1.4|
;;;74     		;
;;;75     	}
;;;76     }
00000c  4770              BX       lr
;;;77     /************************************************************************************************
                          ENDP


                          AREA ||i.Get_Weight||, CODE, READONLY, ALIGN=2

                  Get_Weight PROC
;;;159    ************************************************************************************************/
;;;160    void Get_Weight(void)
000000  b500              PUSH     {lr}
;;;161    {
;;;162    	Weight.DataSample = HX711_Read();
000002  f7fffffe          BL       HX711_Read
000006  4940              LDR      r1,|L2.264|
000008  6148              STR      r0,[r1,#0x14]  ; Weight
;;;163    	Weight.DataSample2 = HX711_2_Read();
00000a  f7fffffe          BL       HX711_2_Read
00000e  493e              LDR      r1,|L2.264|
000010  61c8              STR      r0,[r1,#0x1c]  ; Weight
;;;164    	//printf("重量=%d\r\n",Weight.DataSample);
;;;165    	if((Weight.DataSample > Weight.DataRef) &&(Weight.DataSample2 > Weight.DataRef2)){
000012  4608              MOV      r0,r1
000014  6940              LDR      r0,[r0,#0x14]  ; Weight
000016  6909              LDR      r1,[r1,#0x10]  ; Weight
000018  4288              CMP      r0,r1
00001a  d928              BLS      |L2.110|
00001c  483a              LDR      r0,|L2.264|
00001e  69c0              LDR      r0,[r0,#0x1c]  ; Weight
000020  4939              LDR      r1,|L2.264|
000022  6989              LDR      r1,[r1,#0x18]  ; Weight
000024  4288              CMP      r0,r1
000026  d922              BLS      |L2.110|
;;;166    		Weight.DataSample -= Weight.DataRef;		//获取净重
000028  4837              LDR      r0,|L2.264|
00002a  6940              LDR      r0,[r0,#0x14]  ; Weight
00002c  4936              LDR      r1,|L2.264|
00002e  6909              LDR      r1,[r1,#0x10]  ; Weight
000030  1a40              SUBS     r0,r0,r1
000032  4935              LDR      r1,|L2.264|
000034  6148              STR      r0,[r1,#0x14]  ; Weight
;;;167    		Weight.DataSample2 -= Weight.DataRef2;		//获取净重
000036  4608              MOV      r0,r1
000038  69c0              LDR      r0,[r0,#0x1c]  ; Weight
00003a  6989              LDR      r1,[r1,#0x18]  ; Weight
00003c  1a40              SUBS     r0,r0,r1
00003e  4932              LDR      r1,|L2.264|
000040  61c8              STR      r0,[r1,#0x1c]  ; Weight
;;;168    		Weight.CurWeight = (u16)((float)(Weight.DataSample+Weight.DataSample2)/Weight.GapValue); 	//计算实物的实际重量
000042  4608              MOV      r0,r1
000044  6940              LDR      r0,[r0,#0x14]  ; Weight
000046  69c9              LDR      r1,[r1,#0x1c]  ; Weight
000048  4408              ADD      r0,r0,r1
00004a  ee000a10          VMOV     s0,r0
00004e  eef80a40          VCVT.F32.U32 s1,s0
000052  482d              LDR      r0,|L2.264|
000054  ed900a03          VLDR     s0,[r0,#0xc]
000058  eeb80a40          VCVT.F32.U32 s0,s0
00005c  ee801a80          VDIV.F32 s2,s1,s0
000060  eebc0ac1          VCVT.U32.F32 s0,s2
000064  ee100a10          VMOV     r0,s0
000068  4927              LDR      r1,|L2.264|
00006a  80c8              STRH     r0,[r1,#6]
00006c  e04a              B        |L2.260|
                  |L2.110|
;;;169    	} else if((Weight.DataSample > Weight.DataRef) &&(Weight.DataSample2 <= Weight.DataRef2)){
00006e  4826              LDR      r0,|L2.264|
000070  6940              LDR      r0,[r0,#0x14]  ; Weight
000072  4925              LDR      r1,|L2.264|
000074  6909              LDR      r1,[r1,#0x10]  ; Weight
000076  4288              CMP      r0,r1
000078  d91d              BLS      |L2.182|
00007a  4823              LDR      r0,|L2.264|
00007c  69c0              LDR      r0,[r0,#0x1c]  ; Weight
00007e  4922              LDR      r1,|L2.264|
000080  6989              LDR      r1,[r1,#0x18]  ; Weight
000082  4288              CMP      r0,r1
000084  d817              BHI      |L2.182|
;;;170    		Weight.DataSample -= Weight.DataRef;		//获取净重
000086  4820              LDR      r0,|L2.264|
000088  6940              LDR      r0,[r0,#0x14]  ; Weight
00008a  491f              LDR      r1,|L2.264|
00008c  6909              LDR      r1,[r1,#0x10]  ; Weight
00008e  1a40              SUBS     r0,r0,r1
000090  491d              LDR      r1,|L2.264|
000092  6148              STR      r0,[r1,#0x14]  ; Weight
;;;171    		Weight.CurWeight = (u16)((float)Weight.DataSample/Weight.GapValue); 	//计算实物的实际重量
000094  4608              MOV      r0,r1
000096  ed900a05          VLDR     s0,[r0,#0x14]
00009a  eef80a40          VCVT.F32.U32 s1,s0
00009e  ed900a03          VLDR     s0,[r0,#0xc]
0000a2  eeb80a40          VCVT.F32.U32 s0,s0
0000a6  ee801a80          VDIV.F32 s2,s1,s0
0000aa  eebc0ac1          VCVT.U32.F32 s0,s2
0000ae  ee100a10          VMOV     r0,s0
0000b2  80c8              STRH     r0,[r1,#6]
0000b4  e026              B        |L2.260|
                  |L2.182|
;;;172    	} else if((Weight.DataSample <= Weight.DataRef) &&(Weight.DataSample2 > Weight.DataRef2)) {
0000b6  4814              LDR      r0,|L2.264|
0000b8  6940              LDR      r0,[r0,#0x14]  ; Weight
0000ba  4913              LDR      r1,|L2.264|
0000bc  6909              LDR      r1,[r1,#0x10]  ; Weight
0000be  4288              CMP      r0,r1
0000c0  d81d              BHI      |L2.254|
0000c2  4811              LDR      r0,|L2.264|
0000c4  69c0              LDR      r0,[r0,#0x1c]  ; Weight
0000c6  4910              LDR      r1,|L2.264|
0000c8  6989              LDR      r1,[r1,#0x18]  ; Weight
0000ca  4288              CMP      r0,r1
0000cc  d917              BLS      |L2.254|
;;;173    		Weight.DataSample2 -= Weight.DataRef2;		//获取净重
0000ce  480e              LDR      r0,|L2.264|
0000d0  69c0              LDR      r0,[r0,#0x1c]  ; Weight
0000d2  490d              LDR      r1,|L2.264|
0000d4  6989              LDR      r1,[r1,#0x18]  ; Weight
0000d6  1a40              SUBS     r0,r0,r1
0000d8  490b              LDR      r1,|L2.264|
0000da  61c8              STR      r0,[r1,#0x1c]  ; Weight
;;;174    		Weight.CurWeight = (u16)((float)Weight.DataSample2/Weight.GapValue); 	//计算实物的实际重量
0000dc  4608              MOV      r0,r1
0000de  ed900a07          VLDR     s0,[r0,#0x1c]
0000e2  eef80a40          VCVT.F32.U32 s1,s0
0000e6  ed900a03          VLDR     s0,[r0,#0xc]
0000ea  eeb80a40          VCVT.F32.U32 s0,s0
0000ee  ee801a80          VDIV.F32 s2,s1,s0
0000f2  eebc0ac1          VCVT.U32.F32 s0,s2
0000f6  ee100a10          VMOV     r0,s0
0000fa  80c8              STRH     r0,[r1,#6]
0000fc  e002              B        |L2.260|
                  |L2.254|
;;;175    	} else {
;;;176    		Weight.CurWeight = 0;
0000fe  2000              MOVS     r0,#0
000100  4901              LDR      r1,|L2.264|
000102  80c8              STRH     r0,[r1,#6]
                  |L2.260|
;;;177    	}
;;;178    	
;;;179    }
000104  bd00              POP      {pc}
;;;180    
                          ENDP

000106  0000              DCW      0x0000
                  |L2.264|
                          DCD      Weight

                          AREA ||i.HX711_2_Read||, CODE, READONLY, ALIGN=2

                  HX711_2_Read PROC
;;;122    ************************************************************************************************/
;;;123    u32 HX711_2_Read(void)	//增益128
000000  b500              PUSH     {lr}
;;;124    {
;;;125    	u32 count; 
;;;126    	#if 1
;;;127    	u8 i; 
;;;128    	Delay_Hx711_Us();
000002  f7fffffe          BL       Delay_Hx711_Us
;;;129      	HX711_SCK2_0(); 
000006  2020              MOVS     r0,#0x20
000008  4916              LDR      r1,|L3.100|
00000a  8348              STRH     r0,[r1,#0x1a]
;;;130      	count=0; 
00000c  2200              MOVS     r2,#0
;;;131      	while(HX711_DOUT2_READ()); 
00000e  bf00              NOP      
                  |L3.16|
000010  4814              LDR      r0,|L3.100|
000012  6900              LDR      r0,[r0,#0x10]
000014  f0000040          AND      r0,r0,#0x40
000018  2800              CMP      r0,#0
00001a  d1f9              BNE      |L3.16|
;;;132      	for(i=0;i<24;i++) { 
00001c  2300              MOVS     r3,#0
00001e  e012              B        |L3.70|
                  |L3.32|
;;;133    	  	HX711_SCK2_1(); 
000020  2020              MOVS     r0,#0x20
000022  4910              LDR      r1,|L3.100|
000024  8308              STRH     r0,[r1,#0x18]
;;;134    	  	count=count<<1; 
000026  0052              LSLS     r2,r2,#1
;;;135    		Delay_Hx711_Us();
000028  f7fffffe          BL       Delay_Hx711_Us
;;;136    		HX711_SCK2_0(); 
00002c  2020              MOVS     r0,#0x20
00002e  490d              LDR      r1,|L3.100|
000030  8348              STRH     r0,[r1,#0x1a]
;;;137    		Delay_Hx711_Us();
000032  f7fffffe          BL       Delay_Hx711_Us
;;;138    	  	if(HX711_DOUT2_READ()) {
000036  480b              LDR      r0,|L3.100|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f0000040          AND      r0,r0,#0x40
00003e  b100              CBZ      r0,|L3.66|
;;;139    			count++; 
000040  1c52              ADDS     r2,r2,#1
                  |L3.66|
000042  1c58              ADDS     r0,r3,#1              ;132
000044  b2c3              UXTB     r3,r0                 ;132
                  |L3.70|
000046  2b18              CMP      r3,#0x18              ;132
000048  dbea              BLT      |L3.32|
;;;140    	  	}
;;;141    	} 
;;;142     	HX711_SCK2_1(); 
00004a  2020              MOVS     r0,#0x20
00004c  4905              LDR      r1,|L3.100|
00004e  8308              STRH     r0,[r1,#0x18]
;;;143        count=count^0x800000;//第25个脉冲下降沿来时，转换数据
000050  f4820200          EOR      r2,r2,#0x800000
;;;144    	Delay_Hx711_Us();
000054  f7fffffe          BL       Delay_Hx711_Us
;;;145    	HX711_SCK2_0();  
000058  2020              MOVS     r0,#0x20
00005a  4902              LDR      r1,|L3.100|
00005c  8348              STRH     r0,[r1,#0x1a]
;;;146    	#endif
;;;147    	return(count);
00005e  4610              MOV      r0,r2
;;;148    }
000060  bd00              POP      {pc}
;;;149    
                          ENDP

000062  0000              DCW      0x0000
                  |L3.100|
                          DCD      0x40020000

                          AREA ||i.HX711_Read||, CODE, READONLY, ALIGN=2

                  HX711_Read PROC
;;;86     ************************************************************************************************/
;;;87     u32 HX711_Read(void)	//增益128
000000  b500              PUSH     {lr}
;;;88     {
;;;89     	u32 count; 
;;;90     	#if 1
;;;91     	u8 i; 
;;;92     	Delay_Hx711_Us();
000002  f7fffffe          BL       Delay_Hx711_Us
;;;93       	HX711_SCK_0(); 
000006  2010              MOVS     r0,#0x10
000008  4916              LDR      r1,|L4.100|
00000a  8348              STRH     r0,[r1,#0x1a]
;;;94       	count=0; 
00000c  2200              MOVS     r2,#0
;;;95       	while(HX711_DOUT_READ()); 
00000e  bf00              NOP      
                  |L4.16|
000010  4814              LDR      r0,|L4.100|
000012  6900              LDR      r0,[r0,#0x10]
000014  f0000080          AND      r0,r0,#0x80
000018  2800              CMP      r0,#0
00001a  d1f9              BNE      |L4.16|
;;;96       	for(i=0;i<24;i++) { 
00001c  2300              MOVS     r3,#0
00001e  e012              B        |L4.70|
                  |L4.32|
;;;97     	  	HX711_SCK_1(); 
000020  2010              MOVS     r0,#0x10
000022  4910              LDR      r1,|L4.100|
000024  8308              STRH     r0,[r1,#0x18]
;;;98     	  	count=count<<1; 
000026  0052              LSLS     r2,r2,#1
;;;99     		Delay_Hx711_Us();
000028  f7fffffe          BL       Delay_Hx711_Us
;;;100    		HX711_SCK_0(); 
00002c  2010              MOVS     r0,#0x10
00002e  490d              LDR      r1,|L4.100|
000030  8348              STRH     r0,[r1,#0x1a]
;;;101    		Delay_Hx711_Us();
000032  f7fffffe          BL       Delay_Hx711_Us
;;;102    	  	if(HX711_DOUT_READ()) {
000036  480b              LDR      r0,|L4.100|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f0000080          AND      r0,r0,#0x80
00003e  b100              CBZ      r0,|L4.66|
;;;103    			count++; 
000040  1c52              ADDS     r2,r2,#1
                  |L4.66|
000042  1c58              ADDS     r0,r3,#1              ;96
000044  b2c3              UXTB     r3,r0                 ;96
                  |L4.70|
000046  2b18              CMP      r3,#0x18              ;96
000048  dbea              BLT      |L4.32|
;;;104    	  	}
;;;105    	} 
;;;106     	HX711_SCK_1(); 
00004a  2010              MOVS     r0,#0x10
00004c  4905              LDR      r1,|L4.100|
00004e  8308              STRH     r0,[r1,#0x18]
;;;107        count=count^0x800000;//第25个脉冲下降沿来时，转换数据
000050  f4820200          EOR      r2,r2,#0x800000
;;;108    	Delay_Hx711_Us();
000054  f7fffffe          BL       Delay_Hx711_Us
;;;109    	HX711_SCK_0();  
000058  2010              MOVS     r0,#0x10
00005a  4902              LDR      r1,|L4.100|
00005c  8348              STRH     r0,[r1,#0x1a]
;;;110    	#endif
;;;111    	return(count);
00005e  4610              MOV      r0,r2
;;;112    }
000060  bd00              POP      {pc}
;;;113    /************************************************************************************************
                          ENDP

000062  0000              DCW      0x0000
                  |L4.100|
                          DCD      0x40020000

                          AREA ||i.Hx711_GPIO_Config||, CODE, READONLY, ALIGN=2

                  Hx711_GPIO_Config PROC
;;;32     ************************************************************************************************/
;;;33     void Hx711_GPIO_Config(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;34     {
;;;35     	GPIO_InitTypeDef GPIO_InitStructure;
;;;36     
;;;37     	RCC_AHB1PeriphClockCmd(RCC_HX711_PORT, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;38     
;;;39     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;40     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽输出模式 */
000010  2000              MOVS     r0,#0
000012  f88d0006          STRB     r0,[sp,#6]
;;;41     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000016  f88d0007          STRB     r0,[sp,#7]
;;;42     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00001a  2003              MOVS     r0,#3
00001c  f88d0005          STRB     r0,[sp,#5]
;;;43     	GPIO_InitStructure.GPIO_Pin = HX711_SCK_PIN;
000020  2010              MOVS     r0,#0x10
000022  9000              STR      r0,[sp,#0]
;;;44     	GPIO_Init(HX711_SCK_PORT, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  480e              LDR      r0,|L5.96|
000028  f7fffffe          BL       GPIO_Init
;;;45     
;;;46     	GPIO_InitStructure.GPIO_Pin = HX711_SCK2_PIN;
00002c  2020              MOVS     r0,#0x20
00002e  9000              STR      r0,[sp,#0]
;;;47     	GPIO_Init(HX711_SCK2_PORT, &GPIO_InitStructure);
000030  4669              MOV      r1,sp
000032  480b              LDR      r0,|L5.96|
000034  f7fffffe          BL       GPIO_Init
;;;48     
;;;49     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输入口 */
000038  2000              MOVS     r0,#0
00003a  f88d0004          STRB     r0,[sp,#4]
;;;50     	GPIO_InitStructure.GPIO_Pin = HX711_DOUT_PIN;
00003e  2080              MOVS     r0,#0x80
000040  9000              STR      r0,[sp,#0]
;;;51     	GPIO_Init(HX711_DOUT_PORT, &GPIO_InitStructure);
000042  4669              MOV      r1,sp
000044  4806              LDR      r0,|L5.96|
000046  f7fffffe          BL       GPIO_Init
;;;52     	//#ifdef DOUBLE_HX711
;;;53     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输入口 */
00004a  2000              MOVS     r0,#0
00004c  f88d0004          STRB     r0,[sp,#4]
;;;54     	GPIO_InitStructure.GPIO_Pin = HX711_DOUT2_PIN;
000050  2040              MOVS     r0,#0x40
000052  9000              STR      r0,[sp,#0]
;;;55     	GPIO_Init(HX711_DOUT2_PORT, &GPIO_InitStructure);
000054  4669              MOV      r1,sp
000056  4802              LDR      r0,|L5.96|
000058  f7fffffe          BL       GPIO_Init
;;;56     	//#endif
;;;57     
;;;58     	
;;;59     }
00005c  bd1c              POP      {r2-r4,pc}
;;;60     /************************************************************************************************
                          ENDP

00005e  0000              DCW      0x0000
                  |L5.96|
                          DCD      0x40020000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Weight
                          %        32

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_hx711.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_hx711_c_5821f0d1____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_hx711_c_5821f0d1____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_hx711_c_5821f0d1____REVSH|
#line 128
|__asm___11_bsp_hx711_c_5821f0d1____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
